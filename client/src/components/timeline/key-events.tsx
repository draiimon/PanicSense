import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { format, parseISO } from 'date-fns';
import { getSentimentColor, getDisasterTypeColor } from '@/lib/colors';

interface TimelineEvent {
  id: number;
  name: string;
  description: string | null;
  timestamp: string;
  location: string | null;
  type: string;
  sentimentImpact: string | null;
}

// Add auto-generated events from sentiment data
interface AutoGeneratedEvent {
  id: number;
  name: string;
  description: string;
  timestamp: string;
  location: string | null;
  type: string;
  sentimentImpact: string | null;
  isGenerated?: boolean;
}

interface KeyEventsProps {
  events: TimelineEvent[];
  title?: string;
  description?: string;
  sentimentPosts?: any[]; // Optional sentiment posts to auto-generate events
}

export function KeyEvents({ 
  events, 
  title = 'Key Events',
  description = 'Major shifts in sentiment patterns',
  sentimentPosts = []
}: KeyEventsProps) {
  const getSentimentBadgeText = (sentiment: string | null) => {
    if (!sentiment) return 'Neutral sentiment change';
    
    switch (sentiment) {
      case 'Panic': return 'Panic sentiment spike';
      case 'Fear/Anxiety': return 'Fear/Anxiety sentiment spike';
      case 'Disbelief': return 'Disbelief sentiment increase';
      case 'Resilience': return 'Resilience sentiment increase';
      case 'Neutral':
      default: return 'Neutral sentiment change';
    }
  };

  const getSentimentVariant = (sentiment: string | null): "default" | "secondary" | "destructive" | "outline" => {
    if (!sentiment) return 'secondary';
    
    switch (sentiment) {
      case 'Panic': return 'destructive';
      case 'Fear/Anxiety': return 'destructive';
      case 'Disbelief': return 'secondary';
      case 'Resilience': return 'default';
      case 'Neutral': 
      default: return 'outline';
    }
  };
  
  // Generate auto events from sentiment posts if no manual events are available
  const generateAutoEvents = (): AutoGeneratedEvent[] => {
    if (events.length > 0 || !sentimentPosts || sentimentPosts.length === 0) {
      return [];
    }
    
    // Group posts by disaster type
    const disasterGroups: Record<string, any[]> = {};
    sentimentPosts.forEach(post => {
      const disasterType = post.disasterType || 'Unknown';
      if (!disasterGroups[disasterType]) {
        disasterGroups[disasterType] = [];
      }
      disasterGroups[disasterType].push(post);
    });
    
    // Generate events for each disaster type
    const generatedEvents: AutoGeneratedEvent[] = [];
    
    Object.entries(disasterGroups).forEach(([disasterType, posts], index) => {
      if (posts.length === 0 || disasterType === 'Unknown' || disasterType === 'Not Specified') {
        return;
      }
      
      // Sort posts by date for each disaster type
      posts.sort((a, b) => {
        const dateA = new Date(a.timestamp).getTime();
        const dateB = new Date(b.timestamp).getTime();
        return dateA - dateB;
      });
      
      // Get first post for this disaster type
      const firstPost = posts[0];
      
      // Count sentiments for this disaster type
      const sentimentCounts: Record<string, number> = {};
      posts.forEach(post => {
        const sentiment = post.sentiment || 'Neutral';
        sentimentCounts[sentiment] = (sentimentCounts[sentiment] || 0) + 1;
      });
      
      // Find dominant sentiment
      let dominantSentiment = 'Neutral';
      let maxCount = 0;
      Object.entries(sentimentCounts).forEach(([sentiment, count]) => {
        if (count > maxCount) {
          maxCount = count;
          dominantSentiment = sentiment;
        }
      });
      
      // Get all unique locations
      const locations = Array.from(new Set(posts.filter(p => p.location).map(p => p.location)));
      const locationStr = locations.length > 0 
        ? locations.slice(0, 3).join(', ') + (locations.length > 3 ? ', and others' : '')
        : null;
      
      // Create event
      generatedEvents.push({
        id: -1 - index,  // Negative IDs to avoid conflicts with real events
        name: `${disasterType} Event Detected`,
        description: `Analysis of ${posts.length} posts related to ${disasterType} ${locationStr ? `in ${locationStr}` : ''}. Dominant public sentiment: ${dominantSentiment}.`,
        timestamp: firstPost.timestamp,
        location: locationStr,
        type: disasterType,
        sentimentImpact: dominantSentiment,
        isGenerated: true
      });
    });
    
    // Sort by date
    return generatedEvents.sort((a, b) => {
      const dateA = new Date(a.timestamp).getTime();
      const dateB = new Date(b.timestamp).getTime();
      return dateB - dateA; // Newest first
    });
  };
  
  // Get final events list (real + auto-generated)
  const allEvents = events.length > 0 
    ? events 
    : generateAutoEvents();

  return (
    <Card className="bg-white rounded-lg shadow">
      <CardHeader className="p-5 border-b border-gray-200">
        <CardTitle className="text-lg font-medium text-slate-800">{title}</CardTitle>
        <CardDescription className="text-sm text-slate-500">
          {events.length === 0 && allEvents.length > 0
            ? `Auto-generated from ${sentimentPosts?.length || 0} data points`
            : description}
        </CardDescription>
      </CardHeader>
      <CardContent className="p-5 relative">
        {/* Timeline */}
        <div className="absolute top-5 bottom-0 left-5 w-0.5 bg-slate-200" />
        
        {/* Events */}
        <div className="ml-10 space-y-8">
          {allEvents.length === 0 ? (
            <p className="text-slate-500">No key events available</p>
          ) : (
            allEvents.map((event) => {
              const color = getSentimentColor(event.sentimentImpact);
              const disasterColor = getDisasterTypeColor(event.type);
              
              // Get disaster icon based on type
              const getDisasterIcon = (type: string) => {
                switch(type.toLowerCase()) {
                  case 'flood':
                    return (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M9 14.25c0-3.314 2.686-6 6-6s6 2.686 6 6-2.686 6-6 6-6-2.686-6-6z" />
                        <path d="M7.5 9c0-1.5-1-2-2-2H3C1.5 7 1 7.5 1 9v12c0 1.5.5 2 2 2h2.5c1 0 2-.5 2-2V9z" />
                      </svg>
                    );
                  case 'typhoon':
                    return (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M12 2v20M17 5H7.5a5 5 0 1 0 0 10H17a5 5 0 1 1 0 10H7.5" />
                      </svg>
                    );
                  case 'earthquake':
                    return (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M2 12h2m8-10v2m8 8h2m-10 8v2M4.9 4.9l1.4 1.4m11.4-1.4l-1.4 1.4m0 11.4l1.4 1.4M6.3 17.7l-1.4 1.4M7 12a5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5z" />
                      </svg>
                    );
                  case 'fire':
                    return (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z" />
                      </svg>
                    );
                  default:
                    return (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                      </svg>
                    );
                }
              };
              
              return (
                <div key={event.id} className="relative pl-8">
                  <div 
                    className="absolute -left-14 mt-1.5 w-7 h-7 rounded-full border-4 border-white flex items-center justify-center"
                    style={{ backgroundColor: disasterColor }}
                  >
                    {getDisasterIcon(event.type)}
                  </div>
                  <h3 className="text-base font-semibold text-slate-800">
                    {event.name}
                  </h3>
                  <p className="text-sm text-slate-500 mt-1">
                    {format(parseISO(event.timestamp), 'MMM d, yyyy - h:mm a')}
                  </p>
                  {event.location && (
                    <p className="text-sm text-slate-500 mt-1">
                      <span className="font-medium">Location:</span> {event.location}
                    </p>
                  )}
                  <p className="text-sm text-slate-600 mt-2">{event.description}</p>
                  <div className="mt-3 flex flex-wrap gap-2">
                    <Badge 
                      variant={getSentimentVariant(event.sentimentImpact)}
                    >
                      {getSentimentBadgeText(event.sentimentImpact)}
                    </Badge>
                    
                    {/* Disaster Type Badge */}
                    <Badge
                      style={{
                        backgroundColor: getDisasterTypeColor(event.type),
                        color: 'white'
                      }}
                    >
                      {event.type}
                    </Badge>
                  </div>
                </div>
              );
            })
          )}
        </div>
      </CardContent>
    </Card>
  );
}
