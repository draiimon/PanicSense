import React, { useRef, useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";
import { 
  Download, 
  LineChart, 
  BarChart4, 
  PieChart, 
  TableProperties,
  Loader2 
} from "lucide-react";
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from "../ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../ui/select";

interface DownloadableMetricsProps {
  data: any[];
  metrics?: {
    accuracy: number;
    precision: number;
    recall: number;
    f1Score: number;
  };
  title?: string;
  description?: string;
}

export const DownloadableMetrics: React.FC<DownloadableMetricsProps> = ({
  data,
  metrics,
  title = "Performance Metrics",
  description = "Visual analysis of model performance with downloadable metrics"
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [chartType, setChartType] = useState<string>("bar");
  const [isGenerating, setIsGenerating] = useState<boolean>(false);
  
  // Top sentiment posts by confidence score
  const topSentimentsByConfidence = React.useMemo(() => {
    if (!Array.isArray(data)) return [];
    
    return [...data]
      .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
      .slice(0, 10);
  }, [data]);

  // Count by sentiment
  const sentimentCounts = React.useMemo(() => {
    if (!Array.isArray(data)) return [];
    
    const counts: Record<string, number> = {
      "Panic": 0, 
      "Fear/Anxiety": 0, 
      "Disbelief": 0, 
      "Neutral": 0, 
      "Resilience": 0
    };
    
    data.forEach(item => {
      if (item.sentiment && counts[item.sentiment] !== undefined) {
        counts[item.sentiment] += 1;
      }
    });
    
    return Object.entries(counts).map(([name, value]) => ({ name, value }));
  }, [data]);

  // Count by language
  const languageCounts = React.useMemo(() => {
    if (!Array.isArray(data)) return [];
    
    const counts: Record<string, number> = {};
    
    data.forEach(item => {
      if (item.language) {
        counts[item.language] = (counts[item.language] || 0) + 1;
      }
    });
    
    return Object.entries(counts)
      .map(([name, value]) => ({ name, value }))
      .sort((a, b) => b.value - a.value);
  }, [data]);

  // Function to generate Matplotlib-style chart on canvas
  const generateChart = () => {
    if (!canvasRef.current) return;
    
    setIsGenerating(true);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      setIsGenerating(false);
      return;
    }
    
    // Set canvas size
    canvas.width = 800;
    canvas.height = 600;
    
    // Clear canvas and set background
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add title
    ctx.font = 'bold 24px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText(title, canvas.width / 2, 40);
    
    // Add subtitle with date
    ctx.font = '16px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(`Generated on ${new Date().toLocaleDateString()}`, canvas.width / 2, 70);
    
    // Draw different chart types
    if (chartType === 'bar') {
      drawBarChart(ctx, sentimentCounts, "Sentiment Distribution");
    } else if (chartType === 'pie') {
      drawPieChart(ctx, languageCounts, "Language Distribution");
    } else if (chartType === 'metrics') {
      drawMetricsTable(ctx, metrics);
    } else if (chartType === 'table') {
      drawTopPostsTable(ctx, topSentimentsByConfidence);
    }
    
    // Add watermark/attribution
    ctx.font = '12px Arial';
    ctx.fillStyle = '#999';
    ctx.textAlign = 'right';
    ctx.fillText('Generated by PanicSense', canvas.width - 20, canvas.height - 20);
    
    setIsGenerating(false);
  };
  
  // Draw bar chart for sentiment distribution
  const drawBarChart = (ctx: CanvasRenderingContext2D, data: any[], subtitle: string) => {
    const chartTop = 120;
    const chartBottom = 500;
    const chartLeft = 100;
    const chartRight = 700;
    const chartHeight = chartBottom - chartTop;
    const barCount = data.length;
    const barWidth = (chartRight - chartLeft) / barCount * 0.8;
    const barSpacing = (chartRight - chartLeft) / barCount * 0.2;
    
    // Find max value for scaling
    const maxValue = Math.max(...data.map(item => item.value));
    
    // Add subtitle
    ctx.font = 'bold 18px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText(subtitle, canvas.width / 2, 100);
    
    // Draw axes
    ctx.beginPath();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.moveTo(chartLeft, chartTop);
    ctx.lineTo(chartLeft, chartBottom);
    ctx.lineTo(chartRight, chartBottom);
    ctx.stroke();
    
    // Draw y-axis ticks and labels
    ctx.textAlign = 'right';
    ctx.font = '14px Arial';
    ctx.fillStyle = '#666';
    
    const yTickCount = 5;
    for (let i = 0; i <= yTickCount; i++) {
      const y = chartBottom - (i / yTickCount) * chartHeight;
      const value = Math.round((i / yTickCount) * maxValue);
      
      ctx.beginPath();
      ctx.moveTo(chartLeft - 5, y);
      ctx.lineTo(chartLeft, y);
      ctx.stroke();
      
      ctx.fillText(value.toString(), chartLeft - 10, y + 5);
    }
    
    // Draw bars and x-axis labels
    const colors = ['#4e79a7', '#f28e2b', '#e15759', '#76b7b2', '#59a14f', '#edc948', '#b07aa1', '#ff9da7', '#9c755f', '#bab0ac'];
    
    data.forEach((item, index) => {
      const barHeight = (item.value / maxValue) * chartHeight;
      const barLeft = chartLeft + index * ((chartRight - chartLeft) / barCount);
      const x = barLeft + barSpacing / 2;
      const y = chartBottom - barHeight;
      
      // Draw bar
      ctx.fillStyle = colors[index % colors.length];
      ctx.fillRect(x, y, barWidth, barHeight);
      
      // Add value on top of bar
      ctx.font = 'bold 14px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      ctx.fillText(item.value.toString(), x + barWidth / 2, y - 5);
      
      // Add x-axis label
      ctx.font = '14px Arial';
      ctx.fillStyle = '#666';
      ctx.save();
      ctx.translate(x + barWidth / 2, chartBottom + 15);
      ctx.rotate(-Math.PI / 4); // Rotate text for angled labels
      ctx.textAlign = 'right';
      ctx.fillText(item.name, 0, 0);
      ctx.restore();
    });
  };
  
  // Draw pie chart for language distribution
  const drawPieChart = (ctx: CanvasRenderingContext2D, data: any[], subtitle: string) => {
    const centerX = canvas.width / 2;
    const centerY = 300;
    const radius = 180;
    
    // Add subtitle
    ctx.font = 'bold 18px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText(subtitle, canvas.width / 2, 100);
    
    // Calculate total for percentages
    const total = data.reduce((sum, item) => sum + item.value, 0);
    
    // Define colors
    const colors = ['#4e79a7', '#f28e2b', '#e15759', '#76b7b2', '#59a14f', '#edc948', '#b07aa1', '#ff9da7', '#9c755f', '#bab0ac'];
    
    // Draw legend
    let legendY = 140;
    data.forEach((item, index) => {
      const color = colors[index % colors.length];
      
      // Draw legend color box
      ctx.fillStyle = color;
      ctx.fillRect(550, legendY, 15, 15);
      
      // Draw legend text
      ctx.font = '14px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'left';
      const percentage = ((item.value / total) * 100).toFixed(1);
      ctx.fillText(`${item.name}: ${item.value} (${percentage}%)`, 575, legendY + 12);
      
      legendY += 25;
    });
    
    // Draw pie slices
    let startAngle = 0;
    data.forEach((item, index) => {
      const sliceAngle = (item.value / total) * 2 * Math.PI;
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
      ctx.closePath();
      
      ctx.fillStyle = colors[index % colors.length];
      ctx.fill();
      
      // Draw slice labels
      if (item.value / total > 0.05) { // Only label slices that are big enough
        const angle = startAngle + sliceAngle / 2;
        const labelRadius = radius * 0.7;
        const labelX = centerX + Math.cos(angle) * labelRadius;
        const labelY = centerY + Math.sin(angle) * labelRadius;
        
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const percentage = ((item.value / total) * 100).toFixed(0);
        ctx.fillText(`${percentage}%`, labelX, labelY);
      }
      
      startAngle += sliceAngle;
    });
  };
  
  // Draw metrics table
  const drawMetricsTable = (ctx: CanvasRenderingContext2D, metrics?: any) => {
    if (!metrics) {
      ctx.font = '16px Arial';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText('No metrics data available', canvas.width / 2, 300);
      return;
    }
    
    // Add subtitle
    ctx.font = 'bold 18px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText('Model Performance Metrics', canvas.width / 2, 100);
    
    // Draw table
    const tableTop = 140;
    const tableLeft = 200;
    const rowHeight = 40;
    const col1Width = 150;
    const col2Width = 150;
    
    // Draw table header
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(tableLeft, tableTop, col1Width + col2Width, rowHeight);
    
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText('Metric', tableLeft + col1Width / 2, tableTop + rowHeight / 2 + 5);
    ctx.fillText('Value', tableLeft + col1Width + col2Width / 2, tableTop + rowHeight / 2 + 5);
    
    // Draw table rows
    const metricsData = [
      { name: 'Accuracy', value: metrics.accuracy.toFixed(4) },
      { name: 'Precision', value: metrics.precision.toFixed(4) },
      { name: 'Recall', value: metrics.recall.toFixed(4) },
      { name: 'F1 Score', value: metrics.f1Score.toFixed(4) }
    ];
    
    metricsData.forEach((item, index) => {
      const rowTop = tableTop + (index + 1) * rowHeight;
      
      // Draw row background (alternating colors)
      ctx.fillStyle = index % 2 === 0 ? '#fff' : '#f9f9f9';
      ctx.fillRect(tableLeft, rowTop, col1Width + col2Width, rowHeight);
      
      // Draw cell borders
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.strokeRect(tableLeft, rowTop, col1Width, rowHeight);
      ctx.strokeRect(tableLeft + col1Width, rowTop, col2Width, rowHeight);
      
      // Draw cell text
      ctx.font = '16px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'left';
      ctx.fillText(item.name, tableLeft + 10, rowTop + rowHeight / 2 + 5);
      
      ctx.textAlign = 'center';
      ctx.fillText(item.value, tableLeft + col1Width + col2Width / 2, rowTop + rowHeight / 2 + 5);
    });
    
    // Draw table border
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      tableLeft, 
      tableTop, 
      col1Width + col2Width, 
      rowHeight * (metricsData.length + 1)
    );
  };
  
  // Draw top posts table
  const drawTopPostsTable = (ctx: CanvasRenderingContext2D, data: any[]) => {
    // Add subtitle
    ctx.font = 'bold 18px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText('Top Posts by Confidence Score', canvas.width / 2, 100);
    
    if (data.length === 0) {
      ctx.font = '16px Arial';
      ctx.fillStyle = '#666';
      ctx.fillText('No data available', canvas.width / 2, 300);
      return;
    }
    
    // Draw table
    const tableTop = 140;
    const tableLeft = 50;
    const tableRight = 750;
    const tableWidth = tableRight - tableLeft;
    const rowHeight = 40;
    
    // Column widths
    const col1Width = 250; // Text
    const col2Width = 100; // Sentiment
    const col3Width = 100; // Language
    const col4Width = 100; // Confidence
    const col5Width = tableWidth - col1Width - col2Width - col3Width - col4Width; // Date
    
    // Draw table header
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(tableLeft, tableTop, tableWidth, rowHeight);
    
    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    
    let colX = tableLeft;
    ctx.fillText('Text', colX + col1Width / 2, tableTop + rowHeight / 2 + 5);
    colX += col1Width;
    ctx.fillText('Sentiment', colX + col2Width / 2, tableTop + rowHeight / 2 + 5);
    colX += col2Width;
    ctx.fillText('Language', colX + col3Width / 2, tableTop + rowHeight / 2 + 5);
    colX += col3Width;
    ctx.fillText('Confidence', colX + col4Width / 2, tableTop + rowHeight / 2 + 5);
    colX += col4Width;
    ctx.fillText('Date', colX + col5Width / 2, tableTop + rowHeight / 2 + 5);
    
    // Draw table rows (limited to 8 rows to fit on the chart)
    const displayData = data.slice(0, 8);
    
    displayData.forEach((item, index) => {
      const rowTop = tableTop + (index + 1) * rowHeight;
      
      // Draw row background (alternating colors)
      ctx.fillStyle = index % 2 === 0 ? '#fff' : '#f9f9f9';
      ctx.fillRect(tableLeft, rowTop, tableWidth, rowHeight);
      
      // Draw cell text
      ctx.font = '12px Arial';
      ctx.fillStyle = '#333';
      
      // Text (truncated)
      let text = item.text || '';
      if (text.length > 25) {
        text = text.substring(0, 25) + '...';
      }
      ctx.textAlign = 'left';
      ctx.fillText(text, tableLeft + 10, rowTop + rowHeight / 2 + 5);
      
      // Sentiment
      colX = tableLeft + col1Width;
      ctx.textAlign = 'center';
      ctx.fillText(item.sentiment || 'N/A', colX + col2Width / 2, rowTop + rowHeight / 2 + 5);
      
      // Language
      colX += col2Width;
      ctx.fillText(item.language || 'N/A', colX + col3Width / 2, rowTop + rowHeight / 2 + 5);
      
      // Confidence
      colX += col3Width;
      ctx.fillText(
        item.confidence ? (item.confidence * 100).toFixed(1) + '%' : 'N/A', 
        colX + col4Width / 2, 
        rowTop + rowHeight / 2 + 5
      );
      
      // Date
      colX += col4Width;
      const date = item.timestamp ? new Date(item.timestamp).toLocaleDateString() : 'N/A';
      ctx.fillText(date, colX + col5Width / 2, rowTop + rowHeight / 2 + 5);
      
      // Draw horizontal line
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tableLeft, rowTop + rowHeight);
      ctx.lineTo(tableRight, rowTop + rowHeight);
      ctx.stroke();
    });
    
    // Draw table border
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      tableLeft, 
      tableTop, 
      tableWidth, 
      rowHeight * (displayData.length + 1)
    );
    
    // Draw column dividers
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    
    colX = tableLeft + col1Width;
    ctx.beginPath();
    ctx.moveTo(colX, tableTop);
    ctx.lineTo(colX, tableTop + rowHeight * (displayData.length + 1));
    ctx.stroke();
    
    colX += col2Width;
    ctx.beginPath();
    ctx.moveTo(colX, tableTop);
    ctx.lineTo(colX, tableTop + rowHeight * (displayData.length + 1));
    ctx.stroke();
    
    colX += col3Width;
    ctx.beginPath();
    ctx.moveTo(colX, tableTop);
    ctx.lineTo(colX, tableTop + rowHeight * (displayData.length + 1));
    ctx.stroke();
    
    colX += col4Width;
    ctx.beginPath();
    ctx.moveTo(colX, tableTop);
    ctx.lineTo(colX, tableTop + rowHeight * (displayData.length + 1));
    ctx.stroke();
  };

  // Function to handle downloading the chart as an image
  const handleDownload = () => {
    if (!canvasRef.current) return;
    
    // Create a temporary link element
    const link = document.createElement('a');
    
    // Name file based on chart type
    let filename;
    switch (chartType) {
      case 'bar':
        filename = 'sentiment-distribution.png';
        break;
      case 'pie':
        filename = 'language-distribution.png';
        break;
      case 'metrics':
        filename = 'performance-metrics.png';
        break;
      case 'table':
        filename = 'top-posts.png';
        break;
      default:
        filename = 'chart.png';
    }
    
    link.download = filename;
    
    // Convert canvas to data URL
    link.href = canvasRef.current.toDataURL('image/png');
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Generate chart when chart type changes
  useEffect(() => {
    generateChart();
  }, [chartType]);

  return (
    <Card className="h-full overflow-hidden">
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <LineChart className="h-5 w-5 text-violet-500" />
            <CardTitle className="text-base font-medium">{title}</CardTitle>
          </div>
          <div className="flex items-center gap-2">
            <Select value={chartType} onValueChange={setChartType}>
              <SelectTrigger className="w-[180px] h-8">
                <SelectValue placeholder="Select chart type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="bar">
                  <div className="flex items-center gap-2">
                    <BarChart4 className="h-4 w-4" />
                    <span>Sentiment Bar Chart</span>
                  </div>
                </SelectItem>
                <SelectItem value="pie">
                  <div className="flex items-center gap-2">
                    <PieChart className="h-4 w-4" />
                    <span>Language Pie Chart</span>
                  </div>
                </SelectItem>
                <SelectItem value="metrics">
                  <div className="flex items-center gap-2">
                    <LineChart className="h-4 w-4" />
                    <span>Performance Metrics</span>
                  </div>
                </SelectItem>
                <SelectItem value="table">
                  <div className="flex items-center gap-2">
                    <TableProperties className="h-4 w-4" />
                    <span>Top Posts Table</span>
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            <Button 
              variant="outline" 
              size="sm" 
              onClick={handleDownload} 
              className="h-8"
              disabled={isGenerating}
            >
              {isGenerating ? (
                <Loader2 className="h-4 w-4 mr-1 animate-spin" />
              ) : (
                <Download className="h-4 w-4 mr-1" />
              )}
              Save Image
            </Button>
          </div>
        </div>
        <p className="text-sm text-slate-500">{description}</p>
      </CardHeader>
      <CardContent>
        <div className="flex justify-center">
          <div className="relative overflow-auto max-w-full">
            <canvas 
              ref={canvasRef} 
              className="border border-slate-200 rounded-lg shadow-sm" 
              width={800}
              height={600}
              style={{ maxWidth: '100%', height: 'auto' }}
            />
            {isGenerating && (
              <div className="absolute inset-0 flex items-center justify-center bg-white/80">
                <div className="flex flex-col items-center">
                  <Loader2 className="h-8 w-8 animate-spin text-violet-600" />
                  <p className="mt-2 text-sm text-violet-800">Generating chart...</p>
                </div>
              </div>
            )}
          </div>
        </div>
        
        {/* Show real-time table data for reference */}
        {chartType === 'table' && (
          <div className="mt-6">
            <h3 className="font-medium text-sm mb-2">Top Posts by Confidence Score</h3>
            <div className="border rounded-lg max-h-[300px] overflow-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Text</TableHead>
                    <TableHead>Sentiment</TableHead>
                    <TableHead>Language</TableHead>
                    <TableHead>Confidence</TableHead>
                    <TableHead>Date</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {topSentimentsByConfidence.map((item, index) => (
                    <TableRow key={index}>
                      <TableCell className="max-w-[300px] truncate">{item.text}</TableCell>
                      <TableCell>{item.sentiment}</TableCell>
                      <TableCell>{item.language}</TableCell>
                      <TableCell>{item.confidence ? `${(item.confidence * 100).toFixed(1)}%` : 'N/A'}</TableCell>
                      <TableCell>{item.timestamp ? new Date(item.timestamp).toLocaleDateString() : 'N/A'}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};